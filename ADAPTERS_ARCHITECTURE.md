# üîÑ Arquitectura de Adapters - Gu√≠a Completa

## üìã Tabla de Contenidos

- [¬øQu√© son los Adapters?](#-qu√©-son-los-adapters)
- [¬øPor qu√© en Domain, no en Infrastructure?](#-por-qu√©-en-domain-no-en-infrastructure)
- [Estructura de Archivos](#-estructura-de-archivos)
- [Implementaci√≥n](#-implementaci√≥n)
- [Patrones Defensivos](#-patrones-defensivos)
- [Uso en Repositorios](#-uso-en-repositorios)

---

## üéØ ¬øQu√© son los Adapters?

**Adapter** = Objeto responsable de **transformar datos** entre diferentes representaciones.

### Prop√≥sito:

- üîÑ Transformar respuestas del API ‚Üí Entidades del dominio
- üîÑ Transformar DTOs ‚Üí Requests del API
- üõ°Ô∏è Proteger contra cambios en APIs externas
- üõ°Ô∏è Aplicar valores por defecto defensivos

### Ejemplo:

```typescript
// API Response (estructura externa)
{
  "id": 1,
  "name": "John",
  "email": null  // ‚ö†Ô∏è Puede ser null
}

// ‚¨áÔ∏è Adapter transforma ‚¨áÔ∏è

// Domain Entity (estructura interna)
{
  id: 1,
  name: "John",
  email: "no-email@example.com"  // ‚úÖ Valor por defecto
}
```

---

## üí° ¬øPor qu√© en Domain, no en Infrastructure?

### ‚ùå Ubicaci√≥n INCORRECTA: Infrastructure

```
src/modules/posts/
‚îú‚îÄ‚îÄ domain/
‚îî‚îÄ‚îÄ infrastructure/
    ‚îî‚îÄ‚îÄ adapters/          # ‚ùå INCORRECTO
        ‚îî‚îÄ‚îÄ PostAdapter.ts
```

**¬øPor qu√© est√° mal?**

- üî¥ Los adapters definen **reglas de transformaci√≥n** ‚Üí Eso es **l√≥gica de dominio**
- üî¥ Infrastructure debe ser "tonto" (solo implementaci√≥n t√©cnica)
- üî¥ Mezcla conceptos: transformaci√≥n (dominio) con implementaci√≥n (infra)

---

### ‚úÖ Ubicaci√≥n CORRECTA: Domain

```
src/modules/posts/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ adapters/          # ‚úÖ CORRECTO
‚îÇ       ‚îî‚îÄ‚îÄ PostAdapter.ts
‚îî‚îÄ‚îÄ infrastructure/
    ‚îî‚îÄ‚îÄ repositories/
```

**¬øPor qu√© est√° bien?**

- ‚úÖ Transformaci√≥n = **Regla de dominio** (c√≥mo debe ser un Post v√°lido)
- ‚úÖ Domain define QU√â y C√ìMO transformar
- ‚úÖ Infrastructure solo usa el adapter (no lo define)
- ‚úÖ Testear adapters sin tocar infrastructure

---

## üìÅ Estructura de Archivos

### Organizaci√≥n por M√≥dulo

```
src/modules/{module}/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ adapters/                    # üîÑ Adapters del m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ {Entity}Adapter.ts       # Adapter de la entidad
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts                 # Barrel export (opcional)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ validators/
‚îÇ
‚îî‚îÄ‚îÄ infrastructure/
    ‚îú‚îÄ‚îÄ repositories/                # Usa los adapters
    ‚îî‚îÄ‚îÄ types/                       # API types
```

### Ejemplo Real: M√≥dulo Posts

```
src/modules/posts/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ adapters/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PostAdapter.ts          # ‚úÖ Aqu√≠
‚îÇ   ‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ validators/
‚îÇ
‚îî‚îÄ‚îÄ infrastructure/
    ‚îú‚îÄ‚îÄ repositories/
    ‚îÇ   ‚îî‚îÄ‚îÄ JsonPlaceholderPostRepository.ts  # USA PostAdapter
    ‚îî‚îÄ‚îÄ types/
        ‚îî‚îÄ‚îÄ PostAPITypes.ts         # Define tipos del API
```

---

## üîß Implementaci√≥n

### 1. Estructura del Adapter

```typescript
// src/modules/posts/domain/adapters/PostAdapter.ts

import type {
  PostAPICreateRequest,
  PostAPIResponse,
  PostAPIUpdateRequest,
} from '../../infrastructure/types/PostAPITypes'
import type { CreatePostDto, UpdatePostDto } from '../dtos'
import type { Post } from '../entities/Post'

/**
 * Adaptador defensivo para transformar datos entre API y dominio
 *
 * Responsabilidades:
 * - Transformar respuestas del API ‚Üí Entidades del dominio
 * - Transformar DTOs ‚Üí Requests del API
 * - Aplicar valores por defecto para campos opcionales/null
 * - Proteger contra cambios en la estructura del API
 */
export const PostAdapter = {
  /**
   * Convierte una respuesta del API a una entidad Post del dominio
   */
  toDomain(apiResponse: PostAPIResponse, accountId = 1): Post {
    return {
      id: apiResponse.id ?? 0,
      accountId,
      userId: apiResponse.userId ?? 0,
      title: apiResponse.title ?? 'Untitled',
      body: apiResponse.body ?? '',
    }
  },

  /**
   * Convierte un array de respuestas del API a entidades del dominio
   */
  toDomainList(apiResponses: PostAPIResponse[], accountId = 1): Post[] {
    if (!Array.isArray(apiResponses)) {
      return []
    }
    return apiResponses.map(item => this.toDomain(item, accountId))
  },

  /**
   * Convierte un CreatePostDto a formato esperado por el API
   */
  toAPICreate(dto: CreatePostDto): PostAPICreateRequest {
    return {
      userId: dto.userId,
      title: dto.title,
      body: dto.body,
    }
  },

  /**
   * Convierte un UpdatePostDto a formato esperado por el API
   */
  toAPIUpdate(dto: UpdatePostDto): PostAPIUpdateRequest {
    return {
      id: dto.id,
      userId: dto.userId,
      title: dto.title,
      body: dto.body,
    }
  },
}
```

---

### 2. API Types (Infrastructure)

```typescript
// src/modules/posts/infrastructure/types/PostAPITypes.ts

/**
 * Tipos que representan la estructura del API externo
 * (JSONPlaceholder en este caso)
 */

export interface PostAPIResponse {
  id: number
  userId: number
  title: string
  body: string
}

export interface PostAPICreateRequest {
  userId: number
  title: string
  body: string
}

export interface PostAPIUpdateRequest {
  id: number
  userId: number
  title: string
  body: string
}
```

---

### 3. Uso en Repositorios

```typescript
// src/modules/posts/infrastructure/repositories/JsonPlaceholderPostRepository.ts

import { PostAdapter } from '../../domain/adapters/PostAdapter'

import type { CreatePostDto, UpdatePostDto } from '../../domain/dtos'
import type { Post } from '../../domain/entities/Post'
import type { IPostRepository } from '../../domain/repositories/IPostRepository'
import type { PostAPIResponse } from '../types/PostAPITypes'

export class JsonPlaceholderPostRepository implements IPostRepository {
  private readonly baseUrl = 'https://jsonplaceholder.typicode.com'

  findAll = async (): Promise<Post[]> => {
    const response = await fetch(`${this.baseUrl}/posts`)
    const data = (await response.json()) as PostAPIResponse[]

    // ‚úÖ Usar adapter para transformar
    return PostAdapter.toDomainList(data)
  }

  findById = async (id: number): Promise<Post | null> => {
    const response = await fetch(`${this.baseUrl}/posts/${id}`)
    const data = (await response.json()) as PostAPIResponse

    // ‚úÖ Usar adapter para transformar
    return PostAdapter.toDomain(data)
  }

  create = async (dto: CreatePostDto): Promise<Post> => {
    const response = await fetch(`${this.baseUrl}/posts`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      // ‚úÖ Usar adapter para preparar request
      body: JSON.stringify(PostAdapter.toAPICreate(dto)),
    })
    const data = (await response.json()) as PostAPIResponse

    // ‚úÖ Usar adapter para transformar respuesta
    return PostAdapter.toDomain(data)
  }

  update = async (dto: UpdatePostDto): Promise<Post> => {
    const response = await fetch(`${this.baseUrl}/posts/${dto.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      // ‚úÖ Usar adapter para preparar request
      body: JSON.stringify(PostAdapter.toAPIUpdate(dto)),
    })
    const data = (await response.json()) as PostAPIResponse

    // ‚úÖ Usar adapter para transformar respuesta
    return PostAdapter.toDomain(data)
  }
}
```

---

## üõ°Ô∏è Patrones Defensivos

### 1. Valores por Defecto

```typescript
toDomain(apiResponse: PostAPIResponse): Post {
  return {
    // ‚úÖ Nullish coalescing para valores por defecto
    id: apiResponse.id ?? 0,
    title: apiResponse.title ?? 'Untitled',
    body: apiResponse.body ?? '',
    // ‚úÖ Protege contra undefined/null del API
  }
}
```

**¬øPor qu√©?**

- APIs pueden cambiar sin avisar
- Campos pueden ser `null` o `undefined`
- Previene errores en tiempo de ejecuci√≥n

---

### 2. Validaci√≥n de Arrays

```typescript
toDomainList(apiResponses: PostAPIResponse[]): Post[] {
  // ‚úÖ Validar que sea array
  if (!Array.isArray(apiResponses)) {
    return []
  }

  return apiResponses.map(item => this.toDomain(item))
}
```

**¬øPor qu√©?**

- API puede devolver `null` en lugar de array vac√≠o
- Previene errores "map is not a function"

---

### 3. Transformaci√≥n de Objetos Anidados

```typescript
// Ejemplo: User con address y company

toDomain(apiResponse: UserAPIResponse): User {
  return {
    id: apiResponse.id ?? 0,
    name: apiResponse.name ?? 'Unknown',

    // ‚úÖ Transformar objetos anidados con valores por defecto
    address: {
      street: apiResponse.address?.street ?? 'N/A',
      suite: apiResponse.address?.suite ?? 'N/A',
      city: apiResponse.address?.city ?? 'N/A',
      zipcode: apiResponse.address?.zipcode ?? 'N/A',
    },

    company: {
      name: apiResponse.company?.name ?? 'N/A',
      catchPhrase: apiResponse.company?.catchPhrase ?? 'N/A',
      bs: apiResponse.company?.bs ?? 'N/A',
    },
  }
}
```

**¬øPor qu√©?**

- Objetos anidados pueden ser `undefined`
- Previene acceso a propiedades de `undefined`

---

### 4. Campos Adicionales del Dominio

```typescript
toDomain(apiResponse: PostAPIResponse, accountId = 1): Post {
  return {
    // Campos del API
    id: apiResponse.id ?? 0,
    userId: apiResponse.userId ?? 0,
    title: apiResponse.title ?? 'Untitled',
    body: apiResponse.body ?? '',

    // ‚úÖ Campos adicionales del dominio (no en API)
    accountId,  // Par√°metro adicional
    createdAt: new Date(),  // Timestamp local
  }
}
```

**¬øPor qu√©?**

- Domain puede tener campos que el API no provee
- Permite enriquecer datos

---

## üìä Comparaci√≥n: Antes vs Despu√©s

### ANTES: Sin Adapter (transformaci√≥n inline)

```typescript
// ‚ùå Repositorio con transformaci√≥n inline
export class JsonPlaceholderPostRepository {
  findAll = async (): Promise<Post[]> => {
    const data = await fetch(...)

    // ‚ùå Transformaci√≥n mezclada con l√≥gica de repositorio
    return data.map(item => ({
      id: item.id ?? 0,
      title: item.title ?? 'Untitled',
      body: item.body ?? '',
      // ... repetir en cada m√©todo
    }))
  }

  findById = async (id: number): Promise<Post | null> => {
    const data = await fetch(...)

    // ‚ùå Duplicar la misma l√≥gica de transformaci√≥n
    return {
      id: data.id ?? 0,
      title: data.title ?? 'Untitled',
      body: data.body ?? '',
    }
  }
}
```

**Problemas:**

- üî¥ Duplicaci√≥n de c√≥digo (transformaci√≥n repetida)
- üî¥ Repositorio hace demasiado (fetch + transformaci√≥n)
- üî¥ Dif√≠cil testear transformaci√≥n por separado
- üî¥ Cambios en transformaci√≥n requieren editar m√∫ltiples m√©todos

---

### DESPU√âS: Con Adapter

```typescript
// ‚úÖ Adapter centralizado
export const PostAdapter = {
  toDomain(apiResponse: PostAPIResponse): Post {
    return {
      id: apiResponse.id ?? 0,
      title: apiResponse.title ?? 'Untitled',
      body: apiResponse.body ?? '',
    }
  },

  toDomainList(apiResponses: PostAPIResponse[]): Post[] {
    return apiResponses.map(item => this.toDomain(item))
  },
}

// ‚úÖ Repositorio delega transformaci√≥n
export class JsonPlaceholderPostRepository {
  findAll = async (): Promise<Post[]> => {
    const data = await fetch(...)
    return PostAdapter.toDomainList(data)  // ‚úÖ Simple
  }

  findById = async (id: number): Promise<Post | null> => {
    const data = await fetch(...)
    return PostAdapter.toDomain(data)  // ‚úÖ Simple
  }
}
```

**Ventajas:**

- ‚úÖ DRY: Transformaci√≥n definida una sola vez
- ‚úÖ SRP: Repositorio solo hace fetch, Adapter solo transforma
- ‚úÖ Testeable: Adapter se testea independientemente
- ‚úÖ Mantenible: Cambios en una sola ubicaci√≥n

---

## üß™ Testing de Adapters

### Test Unitario

```typescript
// PostAdapter.test.ts

import { PostAdapter } from '../PostAdapter'
import type { PostAPIResponse } from '../../../infrastructure/types/PostAPITypes'

describe('PostAdapter', () => {
  describe('toDomain', () => {
    it('debe transformar respuesta completa del API', () => {
      const apiResponse: PostAPIResponse = {
        id: 1,
        userId: 5,
        title: 'Test Post',
        body: 'Test content',
      }

      const result = PostAdapter.toDomain(apiResponse)

      expect(result).toEqual({
        id: 1,
        accountId: 1, // Valor por defecto
        userId: 5,
        title: 'Test Post',
        body: 'Test content',
      })
    })

    it('debe aplicar valores por defecto si faltan campos', () => {
      const apiResponse = {
        id: undefined,
        title: null,
      } as unknown as PostAPIResponse

      const result = PostAdapter.toDomain(apiResponse)

      expect(result.id).toBe(0)
      expect(result.title).toBe('Untitled')
      expect(result.body).toBe('')
    })
  })

  describe('toDomainList', () => {
    it('debe retornar array vac√≠o si input no es array', () => {
      const result = PostAdapter.toDomainList(null as any)
      expect(result).toEqual([])
    })

    it('debe transformar array de respuestas', () => {
      const apiResponses: PostAPIResponse[] = [
        { id: 1, userId: 1, title: 'Post 1', body: 'Body 1' },
        { id: 2, userId: 2, title: 'Post 2', body: 'Body 2' },
      ]

      const result = PostAdapter.toDomainList(apiResponses)

      expect(result).toHaveLength(2)
      expect(result[0].id).toBe(1)
      expect(result[1].id).toBe(2)
    })
  })
})
```

---

## üìù Patrones y Convenciones

### Convenci√≥n de Nombres

```typescript
// Patr√≥n: {Entity}Adapter

PostAdapter
UserAdapter
AccountAdapter
ProductAdapter
```

### M√©todos Est√°ndar

```typescript
export const EntityAdapter = {
  // API ‚Üí Domain
  toDomain(apiResponse: EntityAPIResponse): Entity
  toDomainList(apiResponses: EntityAPIResponse[]): Entity[]

  // Domain ‚Üí API
  toAPICreate(dto: CreateEntityDto): EntityAPICreateRequest
  toAPIUpdate(dto: UpdateEntityDto): EntityAPIUpdateRequest
}
```

---

## üéØ Casos de Uso Avanzados

### 1. M√∫ltiples APIs

```typescript
export const PostAdapter = {
  // JSONPlaceholder API
  fromJSONPlaceholder(response: JSONPlaceholderPost): Post { ... },

  // GraphQL API
  fromGraphQL(response: GraphQLPost): Post { ... },

  // REST v2 API
  fromRESTv2(response: RESTv2Post): Post { ... },
}
```

### 2. Enriquecimiento de Datos

```typescript
toDomain(apiResponse: PostAPIResponse, enrichData?: EnrichData): Post {
  return {
    ...this.basicTransform(apiResponse),

    // ‚úÖ Enriquecer con datos adicionales
    authorName: enrichData?.authorName,
    categoryName: enrichData?.categoryName,
    tags: enrichData?.tags ?? [],
  }
}
```

### 3. Transformaci√≥n Condicional

```typescript
toDomain(apiResponse: PostAPIResponse, options?: Options): Post {
  const base = {
    id: apiResponse.id ?? 0,
    title: apiResponse.title ?? 'Untitled',
  }

  // ‚úÖ Transformaci√≥n condicional seg√∫n opciones
  if (options?.includeBody) {
    base.body = apiResponse.body ?? ''
  }

  if (options?.parseMarkdown) {
    base.bodyHtml = markdownToHtml(base.body)
  }

  return base
}
```

---

## üöÄ Beneficios Clave

### 1. Separaci√≥n de Responsabilidades

```
Infrastructure: Fetch/Save datos (comunicaci√≥n)
Adapter:        Transformar datos (l√≥gica de dominio)
Domain:         Validar/Usar datos (reglas de negocio)
```

### 2. Protecci√≥n contra Cambios del API

```
API cambia estructura ‚Üí Solo editas Adapter
Repositories siguen funcionando sin cambios ‚úÖ
```

### 3. Testabilidad

```typescript
// Test adapter sin tocar network
const mockResponse = { id: 1, ... }
const result = Adapter.toDomain(mockResponse)
expect(result.id).toBe(1)
```

### 4. Reutilizaci√≥n

```
Mismo adapter usado por:
  - JsonPlaceholderRepository
  - LocalStorageRepository
  - InMemoryRepository
```

---

## üìö Ejemplos Completos

### PostAdapter (Simple)

```typescript
export const PostAdapter = {
  toDomain(apiResponse: PostAPIResponse, accountId = 1): Post {
    return {
      id: apiResponse.id ?? 0,
      accountId,
      userId: apiResponse.userId ?? 0,
      title: apiResponse.title ?? 'Untitled',
      body: apiResponse.body ?? '',
    }
  },

  toDomainList(apiResponses: PostAPIResponse[], accountId = 1): Post[] {
    if (!Array.isArray(apiResponses)) return []
    return apiResponses.map(item => this.toDomain(item, accountId))
  },

  toAPICreate(dto: CreatePostDto): PostAPICreateRequest {
    return {
      userId: dto.userId,
      title: dto.title,
      body: dto.body,
    }
  },

  toAPIUpdate(dto: UpdatePostDto): PostAPIUpdateRequest {
    return {
      id: dto.id,
      userId: dto.userId,
      title: dto.title,
      body: dto.body,
    }
  },
}
```

### UserAdapter (Complejo - con objetos anidados)

```typescript
export const UserAdapter = {
  toDomain(apiResponse: UserAPIResponse, accountId = 1): User {
    return {
      id: apiResponse.id ?? 0,
      accountId,
      name: apiResponse.name ?? 'Unknown User',
      username: apiResponse.username ?? 'anonymous',
      email: apiResponse.email ?? 'no-email@example.com',
      phone: apiResponse.phone ?? 'N/A',
      website: apiResponse.website ?? 'N/A',

      // Objetos anidados con valores por defecto
      address: {
        street: apiResponse.address?.street ?? 'N/A',
        suite: apiResponse.address?.suite ?? 'N/A',
        city: apiResponse.address?.city ?? 'N/A',
        zipcode: apiResponse.address?.zipcode ?? 'N/A',
      },

      company: {
        name: apiResponse.company?.name ?? 'N/A',
        catchPhrase: apiResponse.company?.catchPhrase ?? 'N/A',
        bs: apiResponse.company?.bs ?? 'N/A',
      },
    }
  },

  toDomainList(apiResponses: UserAPIResponse[], accountId = 1): User[] {
    if (!Array.isArray(apiResponses)) return []
    return apiResponses.map(item => this.toDomain(item, accountId))
  },

  toAPICreate(dto: CreateUserDto): UserAPICreateRequest {
    return {
      name: dto.name,
      username: dto.username,
      email: dto.email,
      phone: dto.phone,
      website: dto.website,
    }
  },

  toAPIUpdate(dto: UpdateUserDto): UserAPIUpdateRequest {
    return {
      id: dto.id,
      name: dto.name,
      username: dto.username,
      email: dto.email,
      phone: dto.phone,
      website: dto.website,
    }
  },
}
```

---

## üîÑ Migraci√≥n: Infrastructure ‚Üí Domain

### Paso 1: Crear Adapter en Domain

```bash
# Crear estructura
mkdir -p src/modules/posts/domain/adapters
touch src/modules/posts/domain/adapters/PostAdapter.ts
```

### Paso 2: Mover C√≥digo

**Antes (infrastructure):**

```typescript
// infrastructure/adapters/PostAdapter.ts
import type { Post, CreatePostDto } from '../../domain/entities/Post'

export const PostAdapter = { ... }
```

**Despu√©s (domain):**

```typescript
// domain/adapters/PostAdapter.ts
import type { CreatePostDto, UpdatePostDto } from '../dtos'
import type { Post } from '../entities/Post'
import type { PostAPIResponse } from '../../infrastructure/types/PostAPITypes'

export const PostAdapter = { ... }
```

### Paso 3: Deprecar Archivo Viejo

```typescript
// infrastructure/adapters/PostAdapter.ts

/**
 * @deprecated Este archivo est√° deprecado.
 * Usa: import { PostAdapter } from '../../domain/adapters/PostAdapter'
 *
 * Los adapters son l√≥gica de dominio (transformaci√≥n de datos),
 * no de infraestructura. Este archivo se mantiene por compatibilidad.
 */
export { PostAdapter } from '../../domain/adapters/PostAdapter'
```

### Paso 4: Actualizar Imports

```typescript
// Antes
import { PostAdapter } from '../adapters/PostAdapter'

// Despu√©s
import { PostAdapter } from '../../domain/adapters/PostAdapter'
```

---

## üéì Resumen

### Adapters en Clean Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         PRESENTATION LAYER              ‚îÇ
‚îÇ  (Components, Hooks, Pages)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         APPLICATION LAYER               ‚îÇ
‚îÇ  (Use Cases)                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          DOMAIN LAYER                   ‚îÇ
‚îÇ  ‚Ä¢ Entities                             ‚îÇ
‚îÇ  ‚Ä¢ DTOs                                 ‚îÇ
‚îÇ  ‚Ä¢ Adapters    ‚Üê üîÑ AQU√ç               ‚îÇ
‚îÇ  ‚Ä¢ Validators                           ‚îÇ
‚îÇ  ‚Ä¢ Repositories (interfaces)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       INFRASTRUCTURE LAYER              ‚îÇ
‚îÇ  ‚Ä¢ Repositories (implementations)       ‚îÇ
‚îÇ  ‚Ä¢ API Types                            ‚îÇ
‚îÇ  ‚Ä¢ External Services                    ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  Usa Adapters del Domain ‚Üë              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Checklist de Implementaci√≥n

- [x] Adapters en `domain/adapters/`
- [x] API Types en `infrastructure/types/`
- [x] Valores por defecto para todos los campos
- [x] Validaci√≥n de arrays
- [x] Manejo de objetos anidados
- [x] M√©todos `toDomain`, `toDomainList`, `toAPICreate`, `toAPIUpdate`
- [x] Documentaci√≥n con JSDoc
- [x] Tests unitarios

---

## üìñ Referencias

- [Adapter Pattern - GOF](https://en.wikipedia.org/wiki/Adapter_pattern)
- [Clean Architecture - Adapters](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Domain-Driven Design - Adapters](https://martinfowler.com/bliki/DomainDrivenDesign.html)

---

**Creado:** Octubre 2025  
**√öltima actualizaci√≥n:** Octubre 2025  
**Mantenedor:** Equipo de Desarrollo
